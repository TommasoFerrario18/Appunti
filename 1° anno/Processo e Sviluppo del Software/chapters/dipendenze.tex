\chapter{Dipendenze}
Vogliamo sviluppare in componenti indipendnenti, ciascun componente
può avere delle dipendenze e queste possono essere soddisfatte:
\begin{itemize}
    \item dinamicamente: non serve il codice all'interno del deplou
    \item staticamente: serve il codice delle componenti dipendenti in fase di
    deployment (mancanza di disaccoppaimento)
\end{itemize}

L'obiettivo è di disaccoppiare i componenti, 2 pattern:
\begin{itemize}
    \item inversion control: si ha un elemento esterno che definisce il valore 
    della dipendenza, servizio che riempie i riferimenti dallesterno (dependency injection)
    \item service locator: si implementa un componente che gestisce le dipendenze
    per accedere ai componenti, servizio per la ricerca dei riferimenti.
\end{itemize}

Depenedecy injection, si aggiunge un oggetto: assembler che si occupa di connettere
due componenti: ex: sceglie l'implementazione di un'interfaccia per una classe.+

L'assembler valorizza i riferimenti al momento dell'istanziamento del componente, 
in questo modo è totalmente trasparente. Lo può fare tramite:
\begin{itemize}
    \item costruttore
    \item setter
    \item interfacce
    \item reflection
\end{itemize}
Si usano le annotazioni e config file per configurare le risoluzioni delle dipendenze 
a runtime. Ex: spring usa Autowired 



Altrimenti è c'è il Dependency lookup, c'è un servizio di locator (singleton con map)
che tiene traccia dei componenti instanziati e quindi i componenti interrognao il lookup per 
sapere quali sono le implementazioni istanziate e quali returnare.


\section{Transaction}
Possiamo specificare una semantica transazionale sulla classe o su un metodo o attributo.
Se noi invochiamo metodi transazionali allora questo permette di definire dei comportamenti
transazionali.

Tipi:
\begin{itemize}
    \item not supported: il codice eseguito non fa parte della transazione.
    \item support: dipende dal chiamante se c'è una transazione in corso anche quelle
    successive fanno parte della transazione.
    \item required: richiede che deve essere presente una transaction, se il chiamante
    non è in una transazione allora si avvia una nuova transazione, al contrario usa 
    quella del chiamante
    \item requiresnew: crea una nuova transaction ad hoc
    \item mandatory: il codice deve far parte della stessa transazione.
    \item never: non viene mai eseguito in un contesto dei transaction
\end{itemize}

Spesso si ha indipendenza imperfetta:
\begin{itemize}
    \item dirtu reads: una transazione che legge un dato di una transaction che non 
    va a buon fine
    \item unrepeateble reads: transazioni che legge valori modificata dall'altra.
    \item phantom read: valori letti da una transazione che sono stati creati in una nuova 
\end{itemize}
Questo può essere settato nel DBMS o nelle annotazioni.

L'isolazione delle transazioni:
\begin{itemize}
    \item forte indipendenza: performance basse
    \item bassa indipendenza: performance alte 
\end{itemize}