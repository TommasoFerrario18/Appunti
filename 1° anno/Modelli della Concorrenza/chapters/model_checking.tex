\chapter{Model checking}
\section{Introduzione}
Le \textbf{logiche temporali} sono una famiglia di logiche matematiche che
permette di esprimere proprietà che cambiano nel tempo.

Quando si analizzano sistemi reattivi (quindi concorrenti) allora non vale più
il ragionamento di avere uno stato precedente e uno stato successivo che varia nel
tempo.

Sono stati introdotti diversi modelli per modellare i sistemi concorrenti, ora
si introdurranno nuove tecniche di analisi.

Esempio produttore consumatore in Java. Esempio concorrente e gli elementi sono
indipendenti quindi si devono sincronizzare quando si accede al buffer. Vogliamo
garantire la correttezza del programma:
\begin{itemize}
    \item Ogni oggetto deve essere prima prodotto
    \item Ogni oggetto non può essere consumato più di una volta
    \item Il sistema non raggiunge mai uno stato di \textbf{deadlock}
\end{itemize}
Le reti di Petri ci permettono di controllare se si mantiene la mutua esclusione,
ovvero che non esista una  marcatura in cui entrambi i processi non possono essere
negli stati $c_1$ e $c_2$. Noi vorremmo modellare il blocco di uno dei due
processi se uno si trova nella zona critica.

Vogliamo quindi un modello per verificare se sono valide delle proprietà di
interesse e se il modello rappresenta effettivamente il sistema.
\begin{definizione}
    Un sistema è \textbf{reattivo} se è un sistema concorrente, distribuito e
    asincrono.
\end{definizione}
Una sottoclasse dei sistemi reattivi sono quelli sincroni con un clock ma è una
semplificazione.

I sistemi reattivi non obbediscono più al paradigma input-computazione output,
rendendo quindi impossibile utilizzare le triple di Hoare per dimostrare la
correttezza di un programma. Possiamo sempre riutilizzare la logica di hoare per
dimostrare alcuni pezzi ma dovremmo usare un modo per unire i risultati.

Al posto delle triple di Hoare, utilizzeremo delle \textbf{asserzioni}, ovvero
delle frasi conteneti elementi temporali che descrivono il comportamento del sistema.
\begin{esempio}
    Se è stato spedito un messaggio allora questo prima o poi verrà ricevuto dal
    destinatario
\end{esempio}
\begin{esempio}
    Se si accende una spia di allarme allora questa sarà accesa fino a quando non
    si spegne il dispositivo
\end{esempio}
Vediamo ora come possiamo procedere nell'analisi dei sistemi concorrenti. Il
problema che vogliamo risolvere è quello di stabilire se un sistema reattivo è
corretto. Per fare ciò, seguiremo il seguente schema:
\begin{enumerate}
    \item Si esprime il criterio di correttezza come una formula di un opportuno
          linguaggio logico.
    \item Si modella il sistema nella forma di un sistema di transizioni.
    \item Si valuta se la formula è vera nel sistema di transizioni. (algoritmi)
\end{enumerate}
\begin{definizione}[\textbf{Sistema di transizioni}]
    Un \textbf{sistema di transizioni} è definito da:
    \begin{equation}
        A=(Q,T)
    \end{equation}
    dove:
    \begin{itemize}
        \item $Q$ insieme degli stati (non per forza finito)
        \item $T\subseteq Q\times Q$ insiemi di transizioni di stato
    \end{itemize}
\end{definizione}
\begin{definizione}[\textbf{Cammino}]
    Definiriremo un \textbf{cammino} come una sequeza di stati $\pi$ dove
    \begin{equation}
        \pi = q_0q_1\dots q_n \ (q_i,q_{i+1})\in T \ \forall i
    \end{equation}
    (combacia con la definizione di cammino su grafi).
\end{definizione}
\begin{definizione}[\textbf{Suffisso}]
    Definiriremo un \textbf{suffisso} di ordine $i$ per un cammino $\pi$ è il
    cammino che inizia da uno stato di indice $i$.
    \begin{equation}
        \pi^{(i)} = q_iq_{i+1}\dots q_n
    \end{equation}
\end{definizione}
\begin{definizione}[\textbf{Cammino massimale}]
    Definiriremo un \textbf{cammino massimale} se il cammino è finito e non può
    essere esteso, cioè solo quando il cammino raggiunge uno stato che non ha
    transizioni uscenti. (cammino massimale finito)
\end{definizione}
Il cammino massimale è infinito quando non si ha uno stato pozzo.
\begin{nota}
    Ogni suffisso di un cammino massimale è a sua volta un cammino massimale.
\end{nota}
Posso rappresentare un cammino espandendo la definizione delle espressioni regolari,
aggiungendo $^\omega$ per rappresentare una sequenza infinita. Bisogna prestare
particolare attenzione al fatto che $\omega \neq \ast$, inaftti $\ast$ mi rappresenta
una sequenza arbitraria di valori.
\begin{nota}
    Posso esprimere un cammino come un suffisso di ordine 0.
\end{nota}
\section{Logica Temporale Lineare}
Definiamo la \textbf{sintassi} partendo dalle proposizioni atomiche:
\begin{equation}
    AP=\{ p_1,p_2,\dots,p_i,\dots \}
\end{equation}
composte dalle asserzioni considerate vere a prescindere.
\begin{esempio}
    Il messaggio è stato spedito, la spia di allarme è accesa
\end{esempio}
Definiamo anche le formule ben formate $FBF_{LTL}$:
\begin{itemize}
    \item Ogni proposizione atomica è una formula ben formata.
    \item $\top$ e $\bot$ sono formule ben formate.
    \item se $\alpha,\beta\in FBF$ allora $\alpha\lor \beta,\lnot \alpha \in FBF$
          (da queste si derivano tutti i connettivi logici).
    \item Operatori temporali siano $\alpha$ e $\beta$ formule ben formate, allora
          anche:
          \begin{itemize}
              \item $X\alpha$ "next $\alpha$" nel prossimo stato $\alpha$ è vera.
              \item $F\alpha$ "future $\alpha$" prima o poi $\alpha$ sarà vera.
              \item $G\alpha$ "globally $\alpha$" $\alpha$ è sempre vera.
              \item $\alpha\mathbb{U}\beta$ "until $\alpha$" $\alpha$ è vera fino
                    a quando $\beta$ diventa vera.
          \end{itemize}
          sono formule ben formate.
\end{itemize}
Per definire la sintassi utilizzeremo i \textbf{Modelli di Kripke} che prendono
i sistemi di transizione e li arricchiscono associando a ogni stato $q \in Q$
l'insieme delle proposizioni atomiche che sono vere in $q$. Quindi possiamo
definire:
\begin{equation}
    I \ : \ Q \rightarrow 2 ^{AP}
\end{equation}
dove $2^{AP}$ è l'insieme delle parti di $AP$. Un modello di Kripke sarà definito
come:
\begin{equation}
    A=(Q,T,I)
\end{equation}
Con un modello di Kripke possiamo identificare per uno stato quali sono le
proposizioni atomiche vere e per capire se le FBF sono vere allora dovrò analizzare
i cammini che partono dallo stato in esame.

Vediamo ora come associare una semantica alle formule ben formate. Per fare ciò
procediamo in due fasi:
\begin{enumerate}
    \item Definiamo un criterio per stabilire se una formula $\alpha$ è vera in
          un cammino massimale $\pi$.
    \item Diciamo che la formula è vera rispetto a uno stato $q$ se è vera in
          tutti i cammini massimali che partono da $q$.
\end{enumerate}
Fissiamo quindi un cammino generico $\pi$ e $\alpha$ una formula ben formata allora
\begin{equation}
    \pi \vDash \alpha \iff \ \text{significa che} \ \alpha \ \text{è vera nel cammino}
    \ \pi
\end{equation}
Definiremo la relazione $\vDash$ per induzione.
\begin{definizione}
    Supponiamo che $\alpha$ e $\beta$
    siano due formule ben formate e $p$ una preposizione atomica:
    \begin{itemize}
        \item $\pi \vDash \top$
        \item $\pi \not\vDash \bot$
        \item $\pi \vDash p \iff p\in I(q_0)$
        \item $\pi \vDash \lnot \alpha \iff \pi \not\vDash \alpha$
        \item $\pi \vDash  \alpha \lor \beta \iff (\pi \vDash \alpha)\lor (\pi \vDash
                  \beta) $
        \item Operatori temporali: supponiamo $\beta, \gamma \in FBF$
              \begin{itemize}
                  \item $\pi\vDash X\beta \iff \pi^{(1)}\vDash \beta$
                  \item $\pi\vDash F\beta \iff \exists i \in \mathbb{N}:\pi^{(i)}
                            \vDash \beta$
                  \item $\pi\vDash G\beta \iff \forall i \in \mathbb{N}:\pi^{(i)}
                            \vDash \beta$
                  \item $\pi \vDash \beta \mathbb{U} \gamma \iff$:
                        \begin{itemize}
                            \item $\exists i \in \mathbb{N}$ tale che $\pi^{(i)}\vDash
                                      \gamma$ cioè $\pi\vDash F\gamma$
                            \item $\forall h, 0\le h < i, \pi^{(h)}\vDash \beta$
                        \end{itemize}
                        Se $\gamma$ è vera fin da subito, quindi $i=0$ allora $\beta$
                        è superfluo
              \end{itemize}
    \end{itemize}
\end{definizione}
\begin{esempio}
    Ecco alcuni esempi:
    \begin{itemize}
        \item $FG\alpha$: esprime che da un certo momento in poi $\alpha$ sarà
              invariante, se $\alpha = \perp$ allo stato iniziale ma $FG\alpha = \top$
              vale dallo stato iniziale allora significa che non si tornerà più
              in quello stato.
        \item $GF\alpha$: $\alpha$ è vera in un numero infinito di stati
        \item $G\lnot (cs_1\land cs_2)$: mutua esclusione se $cs_1$ indica il
              processo è nella sezione critica, viceversa $cs_2$.
        \item $G(req \implies XF ack)$:
        \item $G(req \implies (req U ack))$: se c'è la richiesta allora la richiesta
              è pendente fino a quando si ha un'ack. Si differenzia da quella
              precedente dal momento che la richiesta deve rimanere fino a quando
              non si manda l'ack.
        \item $G(req \implies ((req\land \lnot ack) U (\lnot req \land ack)))$:
              si chiede di non rispondere all'inizio e dopo la risposta la richiesta
              viene cancellata
    \end{itemize}
\end{esempio}
\begin{esempio} % Reti di petri?
    Consideriamo la seguente rete di Petri, la quale rappresenta due processi che
    vogliono accedere ad una risorsa condivisa.
    %% TODO: Inserire immagine della rete di petri
    Questa rete è composta da:
    \begin{itemize}
        \item $rd$ la risorsa disponibile.
        \item $sc1$ e $sc2$ le due sezioni critiche.
        \item $snc1$ e $snc2$ le due sezioni non critiche.
        \item $req1$ e $req2$ le due richieste di usare la risorsa.
    \end{itemize}
    Per poter applicare le tecniche di model checking dobbiamo trasformare questa
    rete in un modello di Kripke. Per farlo dobbiamo definire gli stati e le
    transizioni. Una possibile soluzione è quella di calcolare il grafo dei casi
    (o grafo di raggiungibilità) della rete di Petri ed assegnare ad ogni nodo
    un insieme di proposizioni atomiche che sono vere in quel nodo.

    Possiamo quindi definire il grafo dei casi dove per semplicità utilizziamo il
    nodo $1$ come stato iniziale:
    %% TODO: Inserire immagine del grafo dei casi
    dove ogni nodo è rappresentato da:
    \begin{itemize}
        \item $1=\{rd,snc1,snc2\}$
        \item $2=\{rd,req1,snc2\}$
        \item $3=\{rd,snc1,req2\}$
        \item $4=\{rd,req1,req2\}$
        \item $5=\{sc1, snc2\}$
        \item $6=\{snc1,sc2\}$
        \item $7=\{sc1, req 2\}$
        \item $8=\{req1,sc2\}$
    \end{itemize}
    Una volta cstruita la struttura, definiamo delle formule che vogliamo siano
    vere per la situazione in analisi. Studiamo quindi:
    \begin{itemize}
        \item $G\neq (sc_1\land sc_2)$: esprime che non si può raggiungere
              uno stato in cui entrambi i processi sono nella sezione critica.
        \item $G\,(req1\implies F\,sc1)$: esprime che se il processo 1 fa richiesta
              allora prima o poi entrerà nella sezione critica.
    \end{itemize}
    Per verificare le formule dovremmo considerare tutti i cammini massimali che
    partono dallo stato 1 e verificare che le formule siano valide in tutti i
    cammini. Tuttavia, questo caso è complesso e i possibili cammini massimali
    sono potenzialmente infiniti.

    Una via più facile è, osservando che dallo stato si possono raggiungere tutti
    gli altri stati, scorrere la tabella delle formule vere in ciascun stato e
    osservare che in nessun stato è vera la formule $sc_1 \land sc_2$.

    Per la seconda formula non possiamo più applicare questa strategia, ma possiamo
    cercare di confutare la formula: basta trovare un cammino massimale che non
    soddisfi la formula.

    In ogni caso questa seconda formula non è valida in quando potrei avere il
    cammino $(1)(2,4,8)^\omega$ in cui anche il secondo processo fa richiesta e
    ci entra. Posso entrare in un loop in cui solamente il processo due prende
    ogni volta la risorsa quindi la formula non è valida in quel cammino massimale.

    Possiamo comunque trovare cammini in cui vale, come $(1,3,6)^\omega$, in
    quanto in quei tre stati $req1$ è sempre falsa.

    Una possibile soluzione è quella di aggiungere un nuovo stato $9$, duplicando
    lo stato $4$ in modo da implementare un meccanismo di \textbf{turno} in cui
    i processi si alternano nell'uso della risorsa.
\end{esempio}
Come per tutte le logiche, anche per la logica temporale si può definire una
equivalenza tra formule.
\begin{definizione}[\textbf{Equivalenza tra formule}]
    Possiamo definire l'\textbf{equivalenza tra formule} come:
    \begin{equation}
        \alpha \equiv \beta \iff \forall \pi : ( \pi \vDash \alpha \iff \pi \vDash \beta)
    \end{equation}
\end{definizione}
\begin{esempio}
    Vediamo ora alcuni esempi di equivalenza tra formule:
    \begin{itemize}
        \item $F\alpha \equiv \alpha \lor XF\alpha$ se prima o poi $\alpha$ sarà
              vera, allora o è vera in questo stato oppure dal prssimo stato
              $\alpha$ sarà prima o poi vera.
        \item $G\alpha \equiv \alpha \land XG\alpha$ se $\alpha$ Se è sempre vera,
              allora è vera in questo stato e dal prossimo stato sarà sempre vera.
        \item $\alpha U \beta \equiv \beta \lor (\alpha \land X(\alpha U \beta))$
              se $\beta$ è vera non ci interessa altro, oppure $\alpha$ è vera e
              dal prossimo stato $\alpha$ sarà vera fino a quando $\beta$ diventa
              vera.
        \item $FGF \alpha \equiv GF\alpha$ se prima o poi $\alpha$ sarà vera, allora
              da un certo momento in poi $\alpha$ sarà sempre vera.
        \item $GFG\alpha \equiv FG\alpha$ se $\alpha$ è sempre vera, allora da un
              certo momento in poi $\alpha$ sarà sempre vera.
        \item $\top U\alpha \equiv F\alpha$: questo significa che l'operatore
              $F$ non è essenziale
        \item $\lnot F \lnot \alpha\equiv G\alpha$: questo significa che $G$ può
              essere definito a partire da $F$ quindi l'insieme minimale di
              operazioni sono $\{X,U\}$. Questo insieme minimale non è unico.
    \end{itemize}
\end{esempio}
Le equivalenze spesso sfruttano la ricorsione dal momento che si basano su sistemi
di transizione.

Le equivalenze logiche permettono di definire degli \textbf{operatori derivati},
per velocizzare la scrittura delle formule. Alcuni esempi di operatori derivati
sono:
\begin{itemize}
    \item \textbf{Until debole}: $\alpha W \beta \equiv G\alpha \lor
              (\alpha U \beta)$ con questo operatore si può esprimere la proprietà
          in cui $\alpha$ è sempre vera oppure $\alpha$ è vera fino a quando
          $\beta$ diventa vera.
    \item \textbf{Release}: $\alpha R \beta$ per cui
          \begin{equation}
              \pi\vDash\alpha R \beta \iff \forall k\ge 0:(\pi^{(k)}\vDash \beta\lor
              \exists h<k:\pi^{(h)}\vDash \alpha)
          \end{equation}
          In sostanza o $\beta$ è sempre vera oppure $\beta$ potrà essere falsa
          solo quando $\alpha$ diventa vera. Definito in questo modo allora si può dire
          \begin{equation}
              \alpha R \beta \equiv \beta W (\alpha \land \beta)
          \end{equation}
\end{itemize}
\begin{definizione}[\textbf{Insieme di operatori minimale}]
    L'insieme degli operatori è detto \textbf{minimale} se ogni altro
    operatore può essere definito a partire da questi. Un esempio di inisieme di
    operatori minimale per le logiche temporlai è $\{X,U\}$.
\end{definizione}
Attenzione all'uso della negazione nelle formule LTL, cosa significa "non è vero
$F\alpha$"?  Significa che $\exists$ un cammino per cui non vale $F\alpha$.  Mentre
$\lnot F\alpha \equiv G\lnot \alpha$ quindi $\lnot F\alpha$ non è la negazione di
$F\alpha$. Qundi dobbiamo stare attenti ai quantificatori universali nascosti.