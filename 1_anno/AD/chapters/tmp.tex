% Lezione 13-03-2024
\section{Controllo della concorrenza}
Nei sistemi centralizzati la gestione delle letture e delle scritture avviene
attraverso una fase di two phase locking, in cui si acquisiscono i lock in
maniera sequenziale e si rilasciano in maniera sequenziale.

Le transazioni non è detto che lavorano sullo stesso nodo. Ogni transazione 
viene schedulata in modo indipendente dai server di ciascun nodo.

Potrebbe generarsi una situazione di deadlock distribuito, questo perché il 2PL
viene eseguito sui singoli nodi localmente e non c'è un coordinamento globale.
Non posso chiedere lock su macchine diverse. Non posso usare l'idea di cancellare 
le transazioni che aspettano troppo tempo come nei sistemi centralizzati, perché
non c'è un coordinamento globale.

Quando ho le repliche ho dei problemi in fase di scrittura, perché devo aggiornare 
tutte le versioni allo stesso stato. Una soluzione per evitare questo problema
è quella di utilizzare il protocollo \textbf{ROWA} (Read One Write All), in cui
si scrive su tutte le repliche e si legge da una sola. Solo quando tutte le 
repliche hanno scritto si può considerare la transazione completata.

Si paga a livello di performance, bisogna scegliere in base al contesto.

Posso estendere il protocollo 2PL a livello distribuito inserendo un
coordinatore globale, che si occupa di gestire i lock a livello globale. 
Si torna in una situazione simile a quella centralizzata, ma con problemi in 
quanto il coordinatore può diventare un collo di bottiglia e un single point of
failure.

Una possibile soluzione è quella di utilizzare un lock manager secondario, ma 
si hanno problemi di sincronizzazione se cade il primo devo ridirigere tutte le
richieste al secondo.

Una diversa strategia consiste nell'avere una tabella di lock centralizzata dove 
si tiene traccia di tutti i lock acquisiti. I lock manager locali si occupano
di gestire i singoli nodi. Il vantaggio è dovuto al fatto che non si ha un unico
controllo globale.

La gestione centralizzata dei deadlock può essere fatta costruendo un grafo di
dipendenza. Se in questo grafo è presente un ciclo il sistema potrebbe essere in
deadlock. 

Si hanno due modalità di attesa:
\begin{itemize}
    \item Attesa perché un nodo esterno ha richiesto la risorsa e sta eseuendo delle operazioni su essa
    \item Si attende il rilascio della risorsa
\end{itemize}

Una soluzione consiste nel far comunicare i nodi tra di loro. In particolare, si assegna un ordinamento 
ai nodi, ogni nodo esegue un analisi locale e partendo dal più basso si scambiano le informazioni 
in modo che il nodo successivo possa riconoscere il deadlock e rilasciare la risorsa.
Interagisce solamente con le risorse che sono locali ad esso.

Ogni singolo nodo non ha la visibilità globale del sistema, ma solo locale.
\section{Atomicità}
In un sistema distribuito la cosa più problematica è la perdita di informazioni 
nello scambio di messaggi.

Soluzioni centralizzata con un transaction manager

Il transaction manager chiede a tutti se fare commit o rollback, se tutti dicono
commit allora si fa commit, altrimenti rollback.

Prima di fare qualunque operazione scrivo sul file di log eseguo l'operazione e 
poi scrivo nuovamente sul file di log.

Gestione dei timeout per evitare che un nodo si blocchi. Si ha un tempo entro il 
quale si accettano risposte se qualcuno non risponde si fa l'abort della transazione.
su tutti i nodi. Si introduce un secondo timeout per aspettare l'attesa della 
conferma della corretta esecuzione dei vari nodi.

