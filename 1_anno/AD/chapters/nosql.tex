\chapter{NoSQL}
\begin{nota}
      In quest capitolo non si vuole sostenere che i database NoSQL siano
      migliori di quelli relazionali. I database NoSQL sono un'alternativa
      ai database relazionali e non sempre sono la scelta migliore. Per ogni
      applicazione è necessario valutare quale sia la scelta migliore.
\end{nota}
Fino a questo momento abbiamo utilizzato database relazionali per gestire le
nostre applicazioni. Tuttavia, i database relazionali non sono l'unica
opzione disponibile. In questo capitolo, esploreremo un'alternativa ai
database relazionali: i database NoSQL.
\section*{Use Cases}
\subsection*{Crypto}
Iniziamo analizzando il seguente Use Case: un cliente vuole salvare dati legati 
alle crypto che vengono forniti da un API. Con le conoscenze conseguite fino a 
questo momento, salveremo tutto su una tabella di un DBMS relazionale dove si 
hanno 5 colonne:
\begin{itemize}
      \item id
      \item Simbolo
      \item Prezzo\_USD
      \item Prezzo\_EUR
      \item Data
\end{itemize}
Questa soluzione presenta dei problemi, ad esempio, se si volesse salvare
informazioni aggiuntive o se la risposta dell'API si dovesse modificare, si
dovrebbe modificare la tabella. Un altro problema sorge quando nella risposta 
sono contenuti elementi complessi, come ad esempio un array di oggetti. In questa 
situazione, usando un database relazionale, si dovrebbero creare tabelle diverse 
e ogni volta che si vuole fare una nuova interrogazione è necessario fare delle 
join tra le tabelle. Questo comporta un rallentamento delle prestazioni.

Una soluzione per ridurre il numero di join è quello di duplicare i dati, il
problema in questo caso non è più legato alla velocità delle interrogazioni, ma
al mantenere la consistenza dei dati. 

In aggiunta posso ridurre le tabelle unendole creando una grande tabella che può 
essere frammentata a livello fisico, il problema di questa soluzione è che si 
vanno a inserire un elevato numero di valori \texttt{null}.
\subsection*{Social network}
Un altro caso d'uso è il social network in cui si vuole salvare la relazione di
amicizia tra profili, il problema è che se si avessero 1M di utenti, ciascuno con
100 amici, allora la tabella amicizia diventa 100M di record. Troppa complessità
soprattutto per una tabella che verrà usata spesso con delle join.

Il DB relazionali non sono in grado di modellare efficientemente i contesti applicativi
con volumi molto significativi di dati.
\section{Introduzione}
Da questo use case possiamo osservare che il modello relazionale presenta dei
limiti nella gestione dei dati:
\begin{itemize}
      \item Si ha uno svantaggio nel salvare di dati poco omogenei, questo è dovuto
            principalmente alla rigidità dello schema dei modelli relazionali, in
            quanto prima di poter inserire i dati, è necessario definire la loro
            struttura.
      \item Si ha uno svantaggio in relazione al paradigma di programmazione che
            viene usato (Programmazione a oggetti). Questo obbliga a utilizzare
            un ORM per mappare i dati del database relazionale con gli oggetti
            del linguaggio di programmazione.
\end{itemize}
Inoltre, essendo le risposte delle API solitamente in formato JSON, si ha un
ulteriore svantaggio in quanto si deve fare un parsing della risposta per
poterla salvare nel database relazionale.

I database NoSQL sono nati con lo scopo di risolvere alcuni problemi di quelli
relazionali come la scalabilità e la flessibilità. Inoltre, le assunzioni che
si trovano dietro i database relazionali non sono sempre adatte per tutti i
casi d'uso.

Con questo non vogliamo dire che i database NoSQL siano migliori di quelli
relazionali, ma che sono un'alternativa ai database relazionali. Per ogni
applicazione è necessario valutare quale sia la scelta migliore. Di seguito
elenchiamo alcuni motivi per cui utilizzare i database relazionali:
\begin{itemize}
      \item SQL è semplice.
      \item Molto rigido
      \item Vincoli nel database allora le app possono non fare i controlli
      \item ipotesi di mondo chiuso: tutto quello che serve è nel database, se non
            lo so devo inserire il valore \texttt{null}.
      \item Tecnologia stabile e funzionante che alle spalle anni di ricerca e
            sviluppo.
      \item Sono valide le proprietà ACID, molto utili in contesti in cui si
            hanno transazioni.
\end{itemize}
È corretto presentare anche gli svantaggi dei database relazionali:
\begin{itemize}
      \item Modificare una tabella nella quale sono già presenti dei valori è molto
            complicato.
      \item Assunzione mondo chiuso: può risultare troppo pesante in determinate
            situazioni.
      \item Il concetto di minimizzare le ripetizioni dei valori implica la necessità
            di effettuare molte join per ottenere l'informazione desiderata.
      \item Si ha un mapping un attributo ha un valore.
      \item Non è compatibile con i linguaggi di programmazione ad oggetti.
      \item Presenta delle difficoltà nella gestione dei self-join.
      \item È difficilmente scalabile.
\end{itemize}
\begin{nota}
      Il termine NoSQL significa \textit{Not Only SQL}.
\end{nota}
Una caratteristica comune dei database NoSQL è che sono \textbf{schema-free} o
\textbf{schema-less}. Questo significa che non è necessario definire uno schema
prima di poter inserire i dati. L'inserimento dei dati implica per quel dato lo
schema associato, il successivo inserimento di un dato può avere uno schema diverso.

% Presa da internet la definizione
Oltre a ciò, per questi database vale il \textbf{teorema CAP}, il quale afferma
che è impossibile per un sistema distribuito garantire contemporaneamente le
seguenti tre proprietà:
\begin{itemize}
      \item \textbf{Consistency}: tutti i nodi vedono gli stessi dati allo stesso
            tempo.
      \item \textbf{Availability}: ogni richiesta riceve una risposta, anche in
            presenza di guasti.
      \item \textbf{Partition tolerance}: il sistema continua a funzionare anche
            se alcune parti del sistema non sono disponibili.
\end{itemize}
Mentre nei database relazionali avevamo le transazioni \textbf{ACID}, nei database
NoSQL abbiamo le transazioni \textbf{BASE}, che stanno per:
\begin{itemize}
      \item \textbf{Basically Available}: il sistema è sempre disponibile.
      \item \textbf{Soft state}: lo stato del sistema può cambiare anche senza
            input.
      \item \textbf{Eventual consistency}: il sistema diventerà consistente in un
            certo momento.
\end{itemize}

Inoltre, a differenza dei database relazionali, i database NoSQL si basano su
un'assunzione di mondo aperto, ovvero viene inserito solo quello che conosco se
mi mancano delle informazioni non le metto.

Si è passati dal progettare le architetture in modo da essere più specifiche
per l'applicazione, il contrario di come si faceva una volta: progettazione generalista.
\section{Tipi di database NoSQL}
Esistono diverse tipologie di database NoSQL, ognuna con le proprie caratteristiche
e i propri casi d'uso. Possiamo dire che più è semplice il modello, più è facile
scalarlo. Nella figura \ref{fig:tipi_nosql} possiamo osservare come si posizionano i
database NoSQL rispetto alla dimensione e complessità del modello.
\begin{figure}[!ht]
      \centering
      \includegraphics[scale=0.5]{./img/nosql/tipi_nosql.png}
      \caption{Tipi di database NoSQL}
      \label{fig:tipi_nosql}
\end{figure}

Rispetto questa rappresentazione possiamo posizionare il modello relazionale tra
il modello column-based e il modello document-based.

In questo corso vedremo i seguenti tipi di database NoSQL:
\begin{itemize}
      \item \textbf{Document-based}: i dati sono memorizzati in documenti, che
            possono essere in formato JSON, XML, BSON, YAML, etc.
      \item \textbf{Key-value}: i dati sono memorizzati in coppie chiave-valore.
      \item \textbf{Wide-column}: i dati sono memorizzati in colonne, simile ai
            database relazionali.
      \item \textbf{Graph-based}: i dati sono memorizzati in nodi e archi.
\end{itemize}
Una caratteristica che accomuna queste tipologie di database è legata al problema
di mettere insieme i dati. Ad esempio, i database relazionali usano le operazioni
di join, mentre i database document-based usano un unico documento.
\subsection{Key value}
I database \textbf{key-value} sono i più semplici tra i database NoSQL. In questi
database, i dati sono memorizzati come tabelle di hash dove la chiave punta a un
particolare valore. Si utilizzano le tabelle di hash per massimizzare le prestazioni
di lettura e scrittura.
\subsection{Wide column}
I database \textbf{wide-column} sono simili ai database relazionali, ma invece di
memorizzare i dati in righe, i dati sono memorizzati in colonne. Questo permette
di avere una maggiore flessibilità rispetto ai database relazionali. La chiave
punta a un insieme di colonne che può essere diverso per ogni riga.

\paragraph{HBASE}
HBase è un database wide-column che è stato ispirato da Google BigTable. In HBase
si ha una chiave che punta ad un insieme di valori che possono avere tipi differenti.

In questa struttura, possiamo definire delle \textbf{column family}, le quali
contengono più attributi che condividono delle informazioni. Il \textbf{qualifier} è
il nome dell'attributo all'interno di una column family. Ogni riga ha anche
un campo relativo al timestamp in cui è stata modificata.

L'utilizzo di timestamp fornisce un modo diverso per gestire le transazioni,
anche quelle distribuite, senza l'uso di lock. Questo metodo associa a ogni
transazione un timestamp, in modo che se due transazioni si sovrappongono,
possono essere risolte in base a tale valore.

In questa implementazione è possibile realizzare facilmente relazioni di tipo 1-n
nella stessa riga.
\paragraph{Cassandra}
Cassandra è un database wide-column che è stato realizzato da Facebook per gestire
la comunicazione con le mail.

Questo database si differenzia da HBase per il fatto si ha uno spazio delle chiavi,
il quale può essere visto come una tabella nel modello relazionale. Questo spazio
è suddiviso in column family, le quali sono differenti da quelle di HBase in quanto
la stessa chiave primaria può essere usata in più column family.

I valori che si trovano all'interno di una column family possono essere di tipo
diverso, inoltre, ogni riga ha un timestamp associato.

Quindi una column family equivale ad una \textit{tabella}, e si utilizza la chiave
primaria della riga per accedere ad un particolare dato di essa.

L'accesso viene effettuato specificando i seguenti campi:
\begin{itemize}
      \item \texttt{column family}
      \item \texttt{row key}
      \item \texttt{column name}
\end{itemize}
Per semplificare il passaggio da database relazionali a Cassandra, il query
language di Cassandra (CQL) è molto simile a SQL. Attraverso questo meccanismo
è possibile sviluppare un applicazione che è in grado di utilizzare sia database
relazionali che Cassandra senza apportare molte modifiche.

Un vantaggio dell'utilizzo di questo database è legato al fatto che ogni riga è
indipendente dalle altre. Quindi, in un contesto distribuito, è possibile frammentare
come si vuole il database senza dover fare join.
\subsection{Document based}
I database \textbf{document-based} permettono di memorizzare delle informazioni sotto
forma di documenti. Ognuno dei quali è identificato attraverso una chiave unica.
Tutte le operazioni di lettura e manipolazione dei dati avvengono all'interno
dei documenti stessi.
\paragraph{MongoDB}
MongoDB è un database document-based che memorizza i dati in documenti JSON, più
precisamente, utilizza un formato binario di JSON chiamato BSON. Ogni documento
è identificato da una chiave unica, chiamata \texttt{\_id}.

Possiamo immaginare la struttura di un file JSON come un albero, dove la radice
è la chiave \texttt{\_id} e i figli sono i campi del documento.

Questa tipologia permette di salvare i dati come si faceva negli schemi relazionali,
ovvero suddividendo le informazioni in diverse \textbf{collezioni}. Per fare ciò,
si utilizzano i \textbf{riferimenti} tra i documenti. Lo svantaggio di questa
soluzione è che si devono fare molte join per ottenere l'informazione desiderata.

Un'altra soluzione è quella di salvare i dati in un unico documento, sfruttando
l'embedding, in modo da evitare le join. Questo metodo è molto efficiente quando
si devono accedere alle informazioni più vicine alla radice, ma meno efficiente
quando si devono accedere alle foglie, si ha comunque un tempo di accesso minore
rispetto alle join.

Nei database document-based lo schema non è vincolante, in particolare, corrisponde
all'unione di tutti gli attributi e sotto-attributi del documento.

Vediamo ora un parallelismo tra i database relazionali e MongoDB:
\begin{itemize}
      \item \textbf{Database} $\rightarrow$ \textbf{Database}
      \item \textbf{Tabella} $\rightarrow$ \textbf{Collection}
      \item \textbf{Row} $\rightarrow$ \textbf{Document}
      \item \textbf{Column} $\rightarrow$ \textbf{Field}
      \item \textbf{Index} $\rightarrow$ \textbf{Index}
      \item \textbf{Join} $\rightarrow$ \textbf{Embedded document}
      \item \textbf{Foreign key} $\rightarrow$ \textbf{Reference}
      \item \textbf{Partition} $\rightarrow$ \textbf{Shard}
\end{itemize}
Le operazioni che si vogliono svolgere sulla base di dati vengono espresse
attraverso una notazione che ricorda quella della programmazione a oggetti, ovvero
attraverso la \textit{dot notation}. Inoltre, nelle operazioni tutti gli
operatori devono essere espressi in JSON. Questo permette di eliminare l'utilizzo
di framework come Hibernate per mappare gli oggetti sul database.
\begin{nota}
      Quando si devono caricare grandi quantità di dati è utile disabilitare
      l'ack che viene mandato per ogni operazione.
\end{nota}
Le query di modifica di un documento presentano degli oggetti JSON come
clausole, simile alla clausola \texttt{WHERE} delle query SQL. Oltre a questo
è possibile specificare di creare un documento nuovo nel caso non sia presente
quello che si vuole modificare.

Mongo permette di creare degli indici per velocizzare le operazioni.
\begin{esempio}
      Vediamo ora un esempio di parallelismo tra una query SQL e una per
      MongoDB:
      \begin{center}
            db.\textcolor{red}{users}.find(\textcolor{green}{\{age: \{ \$gt: 18 \}\}},
            \textcolor{cyan}{\{name: 1, age: 1\}}).\textcolor{magenta}{limits(10)}
      \end{center}
      \begin{center}
            \textcolor{cyan}{SELECT name, age} \textcolor{red}{FROM users}
            \textcolor{green}{WHERE age $>$ 18} \textcolor{magenta}{LIMIT 10}
      \end{center}
\end{esempio}
Nelle interrogazioni, tutte le clausole sono specificate in \texttt{AND}, se si
vuole specificare in \texttt{OR} è necessario utilizzare il comando $\$or$ seguito
da una lista di oggetti JSON.

Nelle versioni successive è stato definito il concetto di \textbf{aggregation} e
di \textbf{pipeline}. Una pipeline è un comando che rappresenta una sequenza di
operazioni che vengono eseguite in serie e possono essere usate per operazioni
di analytics.

\begin{nota}
      Dato un problema non sempre per avere efficienza dobbiamo scegliere la
      soluzione banale, spesso dobbiamo prendere soluzioni controintuitive. Ex:
      salvare i dati non in modo efficiente e sfruttare la potenza di esecuzione
      delle query dei DBMS.
\end{nota}
\begin{nota}
      Un documento è un albero.
\end{nota}
\subsection{Graph based}
I database graph-based memorizzano i dati salvando le informazioni nei nodi e
utilizzando gli archi per definire delle relazioni tra esse. Questi database sono
utili per memorizzare dati che hanno relazioni complesse, come ad esempio le
relazioni dei social network.

Spesso si usano per reti sociali, recommendations systems, logistica, financial
transaction, bioinformatica, autorizzation and access control.

I database basati sui grafi godono delle seguenti proprietà:
\begin{itemize}
      \item \textbf{Storage}:
            \begin{itemize}
                  \item \textbf{Nativo}: i dati vengono salvati sotto forma di
                        grafo, si ha la problematica legata alla scalabilità 
                        della soluzione.
                  \item \textbf{Non nativo}: i dati vengono salvati in una struttura 
                        differente da un grafo, ma che logicamente permette di essere
                        visto come un grafo.
            \end{itemize}
      \item \textbf{Processing engine}:
            \begin{itemize}
                  \item \textbf{Nativo}: permette di effettuare direttamente query
                        nel linguaggio dei grafi, sfruttando le proprietà dei 
                        grafi. Il problema di questa soluzione è dovuto al fatto 
                        che bisogna mappare le query reali utilizzando le proprietà 
                        del grafo.
                  \item \textbf{Non nativo}: permette di utilizzare un altro 
                        linguaggio (es. SQL) per effettuare query che non devono 
                        per forza essere proprietà del grafo.
            \end{itemize}
\end{itemize}
Lo storage nativo, spesso si basa sull'\textbf{index friend adjacency}, ovvero 
i nodi che sono vicini sono fisicamente salvati insieme. Questo permette di 
effettuare query molto velocemente, ma la costruzione del grafo è molto lenta.

Il collegamento tra concetti si effettua attraverso un cammino tra nodi, mentre 
nel relazionale si effettua tramite valori, invece nel documentale si usa l'embedding.

La struttura a grafo dei dati permette di rappresentare le informazioni 
attraverso un database documentale, ma essendo la base di tale modello una 
struttura ad albero risulta più complesso mappare le relazioni tra i dati. 
Per risolvere questo problema si utilizzando i riferimenti tra vari documenti.

Un modo efficiente per modellare un grafo in modo non nativo è quello di sfruttare 
i vicini. Ad esempio, in un modello documentale possiamo utilizzare l'embedding
per memorizzare i nodi vicini, mentre per i nodi lontani possiamo utilizzare i
riferimenti.

Una seconda soluzione è quella di usare relazioni differenti nel grafo per aumentare
l'espressività del grafo e semplifica i collegamenti. Questo può essere implementato
facilmente.

\begin{esempio}
      Metti l'esempio del confronto delle interrogazioni tra modelli.
\end{esempio}

Nel modello a grafo, ogni nodo rappresenta le informazioni al suo interno con 
delle proprietà, ovvero coppie chiave-valore dove la chiave è rappresentata 
dall'etichetta e il valore rappresenta l'informazione. Anche le relazioni possono
avere un etichetta a cui è associata una proprietà.

Una stessa informazione può essere modellata in modi diversi, la scelta dipende
dalle query che si vogliono effettuare. Le due soluzioni sono:
\begin{itemize}
      \item \textbf{Stessa etichetta}: si ha una sola etichetta per accedere
            a tutte le informazioni, mentre all'interno della relazione si specifica
            il tipo di informazione.
      \item \textbf{Etichette multiple}: si ha una relazione per ogni tipo di
            informazione.
\end{itemize}
Ad esempio, per modellare una situazione in cui a una persona sono associati più
indirizzi, si possono utilizzare le due soluzioni, la scelta dipende dalle 
tipologie di query che si vogliono effettuare. Se si vogliono trovare tutti 
gli indirizzi di una persona, allora è meglio utilizzare una soluzione in cui 
si ha una stessa etichetta per accedere a tutti gli indirizzi e poi all'interno 
della relazione si specifica il tipo di indirizzo. Mentre, se si vogliono 
effettuare query per sapere uno specifico tipo di indirizzo è più conveniente
utilizzare una relazione per ogni tipo di indirizzo. 

\paragraph{Query language}
La modellazione tramite grafo risulta semplice a livello semantico da costruire,
il problema è che non si ha uno standard per il Query language, eccone alcuni:
\begin{itemize}
      \item \textbf{Cypher}: linguaggio dichiarativo basato sul \textbf{pattern-matching 
      query language} (come SQL), infatti cerca tutti i sottografi che metchano 
      con il grafo di query. Permette di effettuare aggregation, ordering
      e limit.

      Il risultato di una query grafo può essere una tabella o un sottografo.
      \item \textbf{Gremlin} (graph traversal language): la query consiste nel specificare 
      un percorso, il percorso si inizializza in tutti i nodi e la query specifica
      dei constrain su archi e nodi per selezionare quali percorsi considerare. 

      Questo linguaggio è pensato per essere eseguito ad agenti, quindi è parallelizzabile
      ed eseguibile in ambienti distribuiti.
\end{itemize}

\paragraph{ArangoDB (Esempio multimodel DB)}

\textbf{ArangoDB} è un DBMS che supporta i seguenti modelli:
\begin{itemize}
      \item \textbf{keyvalue}
      \item \textbf{graph}
      \item \textbf{document}
      \item \textbf{ricerca full text}
\end{itemize}

Tutti i modelli sono gestiti come documenti JSON, più precisamente si hanno due 
documenti principali:
\begin{itemize}
      \item \textbf{databases} (schemas): contengono lo schema generico delle collections 
      \item \textbf{collections} (tables): contengono documenti JSON di tipi simili
\end{itemize} 

In questo modo si possono facilmente gestire i modelli keyvalue. Per quanto riguarda 
il graph model, in questo caso ArangoDB utilizza una collection per specificare 
i nodi, ciascun nodo viene descritto da un documento JSON. Successivamente si 
rappresentano i collegamenti utilizzando una nuova collection che contiene un documento 
JSON per ogni arco. Il documento contiene gli indici dei due nodi e quindi si effettua
il referencing tra documenti. In fase di query si effettuerà la Join per collegare 
i nodi agli archi.

\subsection{Distribuited NoSQL}

I sistemi RDBMS sono facilmente scalabili verticalmente (potenziamento della singola 
macchina), ma non sono facilmente scalabili orizzontalmente (aggiungere nodi all'infinito al cluster).
Questo vincolo è dovuto alle proprietà ACID che devono essere mantenute.

Negli ultimi hanni è stato dimostrato il seguente teorema.

\begin{teorema} [\textbf{CAP}]
      In un sistema distribuito non è possibile che contemporaneamente si hanno 
      le seguenti proprietà garantite:
      \begin{itemize}
            \item consistenza (Consistency)
            \item disponibilità (Availability)
            \item tolleranza alle partizioni (Partision tolerance)
      \end{itemize}      
      Il sistema può soddisfarne al più due contemporanemente.
\end{teorema}

Con la nuova scoperta si ogni DBMS si è incentrato su solo 2 proprietà di quelle 
descritte. Generalmente i RDBMS rispettano CA, mentre per i NoSQL, per via delle 
proprietà BASIC, non si limitano alla combinazione di solo CA. Con queste considerazioni
i sistemi NoSQL sono più facili da scalare (vedi figura \ref{fig:cap}).

\begin{figure} [!h]
      \centering
      \includegraphics[width=0.5\textwidth]{img/nosql/CAP.png}
      \caption{DBMS con le proprietà che assicurano di rispettare}
      \label{fig:cap}
\end{figure}

\paragraph{Keyvalue model: Redis}
Redis essengo un keyvalue non effettua frammentazione, permette di creare dei 
cluster con più nodi e permette di implementare meccanismi automatici e trasparenti
di replica per avere alta Availability.

La replica può essere implementata a livello di cluster, si utilizza un cluster 
"Master" di nodi su cui si effettuano le letture e le scritture, successivamente 
si utilizzano dei cluster "Slave" di nodi su cui si effettua la replica dei cluster 
"Master", questi vengono usati principalmente in lettura. Un'altra implementazione 
è tramite la definizione delle repliche sugli stessi nodi del cluster, questo 
comporta che non abbiamo meccanismi Master-slave a livello di cluster, bensì a livello
di nodi. Quindi per ogni cluster possiamo sia leggere sia scrivere (vedi \ref{fig:dist_redis}). 


\begin{figure} [!h]
      \centering
      \includegraphics[width=0.5\textwidth]{img/nosql/redis_distribuited.png}
      \caption{Due metodologie per replicare con Redis}
      \label{fig:dist_redis}
\end{figure}

\paragraph{Comn Family model: HBASE}
La distribuzione con HBase si basa sul meccanismo Master-slave e sulla frammentazione 
orizzontale, ciascun frammento si chiama \textbf{Region}. 

La distribuzione si basa su 2 componenti:
\begin{itemize}
      \item \textbf{HBase master}: è un'istanza di HBase che si occupa di coordinare gli slave,
      assegna i region agli slave e riconosce i fallimenti. Permette inoltre di 
      effettuare operazioni di admin.
      \item \textbf{Region server}: sono le singole istanze slaves del cluster,
      si occumano di salvare effettivamente i region assegnati dal master e si 
      occupa di gestirli, fornisce le funzioni di lettura e scrittura dei suoi region
      tramite i log. Su ogni Region server si possono implementare meccanismi di replica.
\end{itemize}

Il cluster sarà formato da un nodo HBase master e tanti Region Server, quest'ultimi 
possono avere diversi nodi per la replica. Nel cluster si avrà poi un'orchestratore
(zookeeper) che permette il coordinamento tra Client, Master e Slaves in modo da 
risolvere eventuali problemi di fallimento (vedi \ref{fig:dist_hbase})


\begin{figure} [!h]
      \centering
      \includegraphics[width=0.4\textwidth]{img/nosql/hbase_distribuited.png}
      \caption{Architettura distribuita HBase}
      \label{fig:dist_hbase}
\end{figure}

\paragraph{Comn Family model: CASSANDRA}

Cassandra distribuito ha un'architettura a cluster, ciascuno viene gestito in peer 
to peer con una rete ad anello. I dati vengono partizionati tra in nodi della rete e 
per risolvere i fallimenti si usa la replicaizone. Si scrive e legge su 
qualsiasi nodo, il numero di nodi del cluster può essere aggiornato a runtime. 
Le performance dipendono linearmente rispetto al numero di nodi.

Essendo un'architettura perr-to-peer allora non ha single point of failure 
fornendo massima Availability. In aggiunta si può partizionare il database 
su più cluster differenti e separati geograficamente. 

Cassandra implementa anche la replicazione dei dati di un cluster in due modi:
\begin{itemize}
      \item \textbf{replicazione su un nodo}: si replicano i dati sullo stesso nodo
      \item \textbf{replicazione su un nodo diverso}: si replicano i dati su un altro nodo 
      dello stesso cluster. Questo permette di salvarsi dalla perdita di dati se 
      un nodo si guasta perché ci sarà una replica in un altro nodo.
\end{itemize} 
Si utilizzerà zookeeper per gestire le repliche, nota che le repliche devono essere 
almento $3$.

Il singolo cluster gestisce una partizione del database e nel singolo cluster si 
ha un ulteriore partizionamento dei dati che dai che deve gestire tra i suoi nodi. Il 
partizionamento sul singolo cluster avviene sfruttando l'hashing. I nodi sono 
formano un anello topologico, l'intero anello può essere considerato come un intervallo 
di valori $[0,1]$ che corrisponde all'intervalo dei valori che possono restituire 
le funzioni di hash applicate sulle chiavi. Ciascun nodo viene posizionato nell'anello
ad un particolare valore, in questo modo ciascun nodo si occupa dei dati le cui 
funzioni di hash applicate sull'indice ritorna un valore compreso tra il valore del
nodo precedente e il suo valore. Per risolvere eventuali problemi di overload di 
un nodo, si possono spostare i nodi su altri valori dell'anello topologico e si
replicano i dati di conseguenza. 
Quando si aggiunge un nuovo nodo al cluster, si inserisce nell'anello ad un particolare 
valore e si replicano i dati del nodo successivo che cadono nell'intervallo del 
nuovo nodo nel nuovo nodo.

Dal momento che si ha un'architettura peer-to-peer, per comunicare lo stato 
dei nodi e la locazione dei dati nel cluster si usa il \textbf{gossip protocol},
in sostanza se i dati non sono sul nodo attuale allora chiedo a quelli adiacienti,
i quali se non hanno le informazioni chiedono a quelli adiacienti, fino a quando non 
sono stati visitati tutti. Vista la ridondanza della comunicazione allora 
il protocollo è molto robusto. 

Utilizzando il \textbf{gossip protocol} si può facilemnte \textbf{identificare il fallimento},
infatti ogni nodo tiene salvato la sua probabilità di fallimento e in fase 
di comunicazione, in base alla velocità delle risposte aggiorna la sua probabilità,
in questo modo si aumenta quando le condizioni della rete peggiorano, come la 
latenza ecc\dots

Si usa una soglia che specifica sopra quanto la probabilità deve essere per considerare
il nodo dead. (non si usa il timeout perché è troppo stringente)

% ! non so quanto sia corretto sul failure detection

Le operazioni di scrittura su ciascun nodo seguono questi passi:
\begin{itemize}
      \item scrivo l'operazione nel LOG
      \item scrivo il dato in RAM
      \item quando i dati in RAM sono abbastanza scrivo su disco
\end{itemize}

Dal momento che si hanno partizioni e repliche in un particolare cluster, diventa 
fondamentale gestire la consistenza, in fase di query si deve specificare 
la tipologia di consistenza e il replication\_factor e successivamente in base alle operazioni 
si hanno diversi livelli di consistenza;
\begin{itemize}
      \item scrittura:
      \begin{itemize}
            \item consistency one: si ritorna la risposta al client dopo una scrittura 
            su disco solo su un nodo del cluster
            \item consistency all: si ritorna la risposta al client dopo una scrittura 
            su disco solo su un numero di nodi del cluster pari al replication factor 
            \item consistency quorum: si ritorna la risposta al client dopo $replication\_factor/2+1$ nodi che 
            hanno scritto su disco
      \end{itemize}
      
      \item lettura:
      \begin{itemize}
            \item consistency one: si ritorna la risposta al client dopo la lettura 
            su un nodo del cluster
            \item consistency all: si ritorna la risposta al client dopo una lettura 
            solo su un numero di nodi del cluster pari al replication factor 
      \end{itemize}
\end{itemize} 

Le query di cancellazione vengono implementate attraverso le marcature che 
comunicano che il record è cancellato ma lo cancellano effettivamente in un secondo 
momento, più precisamente attraverso \textbf{major compaction} o dopo un timer.

La \textbf{compaction} consiste nel riorganizzare tutte le SSTables sul singolo nodo per 
eliminare i record marcati, compattare i record se ci sono dei duplicati e infine 
riordinarli. Questo è utile per l'efficienza. Le SSTables sono le strutture su 
disco nelle quali vengono salvati i dati.

Per sincronizzare i dati tra diversi nodi si utilizza l'\textbf{entropia}, in sostanza
si utilizzano degli hash tree, % ! non ci ho capito una sega

Cassandra rientra nella catergoria AP.
\paragraph{Document model: MongoDB}
MongoDB ha un'architettura master (primary) e slave (secondary). 
Si effettuano le scritture sul primary che poi replica sui secondary usando il 
file di LOG del primary.

In sostanza ciascun cluster di nodi è chiamato shard, in ogni shard si identifica un nodo primary 
e tutti gli altri saranno secondary. Se il primary dovesse cadere allora si effettuerà
un'elezione tra i secondary per identificare il nuovo primary, l'elezione si 
baserà sui nodi che sono più aggiornati e in questa fase le scritture si interrompono.

Per identificare quando un nodo dello shard cade si effettua un heartbeat con timeout
per avvisare gli altri che sono attivi, nel replica set si ha una gerarchia dei 
nodi, ogni nodo ha un numero che specifica il livello di priorità. In caso il 
primary cade allora il secondary con la priorità più alta chiede le elezioni. 
Ne replica set si possono avere al massimo 50 nodi di cui $7$ solo votanti.
Un nodo può essere definito:
\begin{itemize}
      \item votante: può lasciare un solo voto
      \item non votante: deve avere priorità a $0$
\end{itemize}

La frammentazione dei dati avviene separando i dati tra i vari shard. 

L'architettura distribuita si basa su 3 componenti:
\begin{itemize}
      \item Mongos: entry point che esegue le query
      \item Config server: server che gestiscono la configurazione del cluster che
      contiene i diversi shard, questi devono essere gestiti in replica set per 
      fornire sempre il servizio
      \item Shards: singoli cluster che salvano un frammento dei dati.
\end{itemize}


Mongo rientra nella catergoria CP.
