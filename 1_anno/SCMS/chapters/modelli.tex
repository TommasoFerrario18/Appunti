\chapter{Modelli}
\section{Automi cellulari}
Gli automi cellulari possono riprodurre fenomeni di auto-riproduzione e
auto-organizzazione, sono utili per modellare sistemi complessi dinamici e la
simulazione. Utili per simulare e studiare sistemi come: traffico, afflusso di
persone, percolazione (studio della fluido dinamica), sistema immunitario, sistemi
sociali etc\dots.

L'idea è di non descrivere il sistema complesso dall'alto, ad alto livello usando
sistemi di equazione differenziali. In realtà lo si fa simulando l'interazione
tra le celle, ognuna delle quali è definita attraverso una serie di regole locali
semplici.

Gli automi cellulari sono dei sistemi dinamici e discreti, dove i termini
rappresentano:
\begin{itemize}
    \item \textbf{Sistemi}: insieme di entità che interagiscono.
    \item \textbf{Dinamici}: evolvono nel tempo in un insieme di passi.
    \item \textbf{Discreti}: spazio, tempo e proprietà devono essere solo finiti
          con un numero numerabile di stati. Spazio finito perché dobbiamo
          rappresentare la realtà.
\end{itemize}
Esistono automi cellulari a più dimensioni che specificano quante dimensioni è lo
spazio.

Lo spazio su cui essi operano è rappresentato da una griglia di celle discrete.
Inoltre, si ha un tempo di evoluzione discreto.

Lo stato che ogni cella assume è definito a partire da un insieme finito di stati
possibili. Inoltre, l'evoluzione di ogni cella è determinata da una regola comune
per tutte le celle, e dipende solamente dallo stato attuale della cella e dagli
stati dei suoi vicini. La regola di aggiornamento è quindi locale e uniforme.
\begin{definizione}[\textbf{Automa cellulare}]
    Un \textbf{automa cellulare} è definito come una tupla:
    \begin{equation*}
        \langle L, Q, q_0, u,f\rangle
    \end{equation*}
    dove:
    \begin{itemize}
        \item $L$: è l'array di automi a stati finiti uniformi.
        \item $Q$: insieme di stati finiti.
        \item $q_0$: è lo stato iniziale.
        \item $u$: è una funzione che definisce il criterio di connessione della
              singola cella con quelle adiacenti.
              \begin{equation*}
                  u: L \rightarrow L^{k}
              \end{equation*}
        \item $f$: la regola di transizione locale.
              \begin{equation*}
                  f: Q^{k} \rightarrow Q
              \end{equation*}
    \end{itemize}
\end{definizione}
Lavorando con automi cellulari finiti, ovvero con lo spazio finito, sarà
importante definire una \textbf{condizione di bordo}, ovvero come deve essere la
regola del vicinato quando le celle sono vicino al bordo. La scelta della
condizione di bordo può essere fatta in questo modo:
\begin{itemize}
    \item Collegare i bordi: i bordi opposti dello spazio sono collegati. Si crea
          quindi un ambiente toroidale.
    \item Guardare i bordi come uno specchio: si considera che il bordo sia uno
          specchio, quindi si riflette il contenuto della cella.
\end{itemize}
Per gli automi cellulari 1-D in cui gli stati delle celle sono binari, si possono
codificare le regole attraverso numeri decimali.

Per mostrare l'evoluzione dell'automa 1D si usa il diagramma spazio-tempo, dove
si mostra l'evoluzione dell'automa nel tempo.
\begin{esempio}[Traffico]
    La regola del traffico è rappresentata dal valore 184. Essa permette di
    modellare semplicemente il flusso del traffico su una strada a singola corsia.

    La rappresentazione del traffico avviene nel seguente modo:
    \begin{figure}[!ht]
        \centering
        \includegraphics[width=0.5\textwidth]{./img/modelli/ese_traffico.png}
        \caption{Esempio di automa cellulare per la rappresentazione del traffico.}
        \label{fig:ese_traffico}
    \end{figure}
    La regola 184 è definita come segue:
    \begin{itemize}
        \item 111: il veicolo rimane fermo (1)
        \item 110: il veicolo si sposta in avanti e quindi la cella rimane vuota
              (0)
        \item 101: la cella è vuota e quindi il veicolo a sinistra si sposta
              occupando la cella (1)
        \item 100: la cella è vuota e quindi il veicolo a sinistra si sposta
              occupando la cella (1)
        \item 011: la cella a destra è occupata quindi il veicolo rimane fermo
              (1)
        \item 010: la cella a destra è vuota e quindi il veicolo si sposta in
              avanti (0)
        \item 001: non ci sono veicoli nella cella attuale e nella precedente
              quindi resta vuota (0)
        \item 000: non ci sono veicoli la cella è vuota (0)
    \end{itemize}

    Questo modello non rappresenta la realtà, in quanto ogni macchina si muove a
    step di 1 se c'è spazio, altrimenti si ferma. Inoltre, non si considera il
    tempo di reazione del guidatore e molti altri fattori.

    Possiamo complicare leggermente il modello sostituendo il valore che
    rappresenta la presenza o meno del veicolo con la velocità del veicolo.
    Si aumenta il raggio delle celle da considerare come vicine. Inoltre, ogni
    veicolo accelera di una velocità fino a quando non rischia di fare incidenti.
\end{esempio}
\begin{nota}
    Le celle possono assumere anche forme differenti da quella quadrata. Ad esempio
    possiamo avere celle triangolari, esagonali e pentagonali. Spesso si usano gli
    esagoni al posto dei quadrati, perché permettono di mantenere la velocità di
    spostamento degli elementi uguale anche in diagonale. Il vicinato ad esagono si
    implementa con 3 vicini da una parte e 3 vicini dall'altra.
\end{nota}
Per gli automi cellulari sarà importante definire un raggio del vicinato. Estendere
il raggio comporta al fatto che la cella è influenzata da più celle, quindi
l'aggiornamento della cella sarà più complesso.
\begin{nota}
    Non abusare dei termini per la relazione, ex: emergenza di un fenomeno.
\end{nota}
Esistono automi che sono invarianti secondo la rotazione, in generale sono quelli
che effettuano un conto sui vicini, inoltre non hanno una direzione dei vicini.
Questi automi sono detti \textbf{totalitaristici}.
\section{Modellazione della folla di persone}
Inizialmente la modellazione delle folle di persone è stata effettuata considerando
le persone indipendenti l'una dall'altra, ottenendo quindi un sistema dove:
\begin{itemize}
    \item Ogni persona ha un proprio obiettivo.
    \item Le altre persone sono considerate come ostacoli.
\end{itemize}
Ora si vuole modellare la folla di persone in cui le persone hanno la possibilità
di muoversi in gruppo.

Un primo studio su questo argomento è stato effettuato da un gruppo di architetti
che hanno studiato il movimento delle persone lungo un marciapiede. Il loro lavoro
è stato quello di osservare la situazione e annotare i movimenti delle persone.

Da questo si è notato che i gruppi tendono ad avere una velocità più bassa e con
una varianza ridotta rispetto al singolo. Lo stesso esperimento è stato ripetuto
in un aeroporto e si è notato che le velocità medie e la varianza cambiano.
Inoltre, più aumenta la dimensione dei gruppi più bassa sarà la velocità e più
sarà costante.

Questo comportamento può essere modellato usando il \textbf{social force model}
con una forza aggiuntiva che modella la formazione di gruppi.

% TODO: immagine gruppi (ex: Line-ABreast, V-like, River-like nei gruppi da 3).

Esistono anche modelli più complessi che non si limitano a gruppi piccoli, in realtà
la moda dei gruppi è spesso $3$. % ! Non mi ricordo la parte sul fatto che la moda sia 3

Un studio diverso è stato effettuato nella galleria vittorio emanuele, dove si è
notato che i gruppi sono composti da un numero compreso tra $1$ a $4$ di elementi.

Si è notato che i singoli sono più veloci e hanno traiettorie meno lineari rispetto
a quello che è stato osservato per i gruppi.

È stata successivamente studiata la dispersione, da questo si è notato che gruppi
piccoli tendono ad essere più coesi a differenza di gruppi più grandi.

Studiato il fenomeno reale si è passati alla definizione del modello. Per fare
questo, si è partiti dai sistemi dinamici discreti, \textbf{floor field CA}. Il
modello è basato su:
\begin{itemize}
    \item spostamento probabilistico
    \item goal oriented: abbiamo un gradiente che specifica la direzione dell'obiettivo
    \item presenza di ostacoli: simula gli ostacoli è statica
    \item presenza di altri pedoni: simula la folla che è dinamica si calcola ad
          ogni passo. Si valuta negativamente perché si cerca di stare lontano.
\end{itemize}
è stato aggiunto:
\begin{itemize}
    \item nozione di gruppo: coesione del gruppo per modellare i gruppi che
          rallenta le persone del gruppo se uno rallenta
\end{itemize}
La modellazione dell'ambiente è stata fatta discretizzandolo, viene quindi
introdotto un errore, e utilizzando dei marker per segnare il punto di ingresso
nel sistema  dove vengono generati gli agenti e un punto di fine, ovvero
l'obiettivo e distruzione di agenti.

Per effettuare lo spostamento degli agenti si determina la metrica della distanza
e questo implica l'induzione di particolari comportamenti. Inoltre è stata implementata
la possibilità di occupare mezza cella aumentando la densità. Si è introdotta la
coesione tra individui dello stesso gruppi.

Si è notato che gli individui hanno una velocità più elevata quando aumenta la
densità, fino a quando è troppa e quindi diventano lenti quanto il singolo.
Addirittura il flusso dei gruppi diventa superiore perché si mettono in coda.

Nell'osservazione reale si notava la dispersione, questo può essere implementato
nel modello sempre calcolando i centroidi e questo permette di testare l'algoritmo
di coesione per confrontarlo nella realtà.

L'aggiornamento degli agenti si può effettuare:
\begin{itemize}
    \item \textbf{Sequential shuffle update}: genero una sequenza di pedoni
          randomica e aggiorno un pedone alla volta.
    \item \textbf{Parallel update}: si sceglie il movimento per ogni pedone, si
          risolvono i conflitti (uno si muove e l'altro no, altrimenti si fermano
          entrambi)
\end{itemize}
L'approccio basato sugli automi cellulari porta ad dei limiti, come le traiettorie
zig-zag, in aggiunta dobbiamo simulare anche la velocità. Questo lo possiamo fare
in base alla frequenza di aggiornamento, dimensione della cella e ottenere la
velocità corrispondente nel mondo reale. 

Se abbiamo velocità diverse (eterogenee) possiamo tranquillamente modificare quante 
volte si muovono per turno, il problema è che ci potrebbe essere il problema di 
traiettorie che si intrecciano, quindi conflitti e anticiparli non è così banale.

Un'alternativa è considerare la velocità come numero reale tra $0-1$ al posto che
il numero di celle.

C'è anche un meccanismo di Reaction Time.

I limiti del modello è che nello spazio possiamo avere corridoi obliqui e quindi
compiamo degli errori nel modello e si può stimare l'errore. Questo è dovuto 
all'utilizzo degli automi cellulari che discretizzano con celle.

Se volessimo modellare le scale allora è come se le celle rallentano la velocità
dell'individuo.

Successivamente si prende il modello e si compara con quanto osservato.

\section{Modellazione Crowd Management}

Questo modello permette di dividere gli agenti in due livelli:
\begin{itemize}
    \item livello operazionale: si occupa di effettuare attività molto semplici 
    tra agenti, come la camminata, interazione tra gli altri e attività da eseguire
    \item livello tattico: si occupa di definire la scelta della strada da intraprendere 
    e/o scegliere ad una strategia.
\end{itemize}

Questi agenti avranno la componente di base di conoscienza. Quindi si avrà un
entre centrale che fornisce le informazioni su dove sono gli obiettivi e a livello
di agente si avrà un algoritmo che sceglie quale target seguire. Si definiscono 
quindi delle annotazioni sull'ambiente che permettono all'algoritmo di definire 
i comportamenti. 

Ogni agente ha una serie di gradienti che indirizzano verso dei punti specifici,
ex: punti di passaggio, oggenti nella stanze, etc...

Ogni agente quindi ha una base di conoscienza relazionale che aggiorna durante la sua simulazione,
quando supera un marker di confine, visiona il gradiente associato alla regione 
e in questo modo aggiorna la sua base di conoscienza aggiungendo le informazioni 
del nuovo gradiente alla sua mappa relazionale.

L'ambiente ha l'insieme di tutti i gradienti che specificano la direzione verso 
le stanze adiacenti da qualsiasi stanza e fornisce la struttura relazionale (mappa,
grafo che specifica le regioni e gli archi che specificano i passaggi) tra 
gli agenti in merito a come sono collegate le stanze.

I ciclo di vita dell'agente corrisponde a:
\begin{itemize}
    \item si basa sulla costruzione del piano: avviene quando l'agente nasce nell'ambiente 
    o quando non vale più quello precedente. Ogni agente  ha l'obiettivo di raggiungere 
    una stanza. Per prima cosa si deve localizzare nella mappa relazionale, chiede 
    all'ambiente il gradiente della stanza, successivamente calcola le stanze da 
    attraversare e segue il gradiente per raggiungere la stanza adiacente scelta.
    Quando arriva al marker che segnala il confine, l'agente riceve dall'ambiente 
    i nuovi gradienti della nuova stanza e ripete il percorso.
    \item aggiornamento
    \item attuazione
\end{itemize}

Il primo limite della cognitive map è il fatto che non si hanno delle metriche 
che specificano le distanze tra le stanze e non è semplice specificare delle metriche.
Possiamo definire degli alberi di percorso che sono composti dai nodi che specificano
i passaggi mentre gli archi specificano le regioni. Per costruire l'albero posso 
partire dall'obiettivo e calcolare tutte le opzioni per ritornare alla partenza. 
In questo modo posso calcolare le distanze metriche (numero di celle 
attraversate che possono essere trasformate in misuere di flusso, ovvero tempo 
di percorrenza). Il probema è che si vuole modellare anche la congestione, 
per fare ciò si utilizzano anche dei layer dinamici, il percorso più corto specifica 
il layer statico, mentre possiamo definire un layer dinamico che misura la congestione.
La misura può essere fatta contando, ogni $n$ iterazioni, quanti agenti sono rimasti 
fermi. In questo modo si pesa il percorso per il grado di congestione. Successivamente 
l'agente deve fare una scelta deterministica, ovvero il percorso più veloce.
Possiamo annotare sempre le aree per dare dei requisiti agli agenti per praticare 
il percorso, si ha un agente selettivo (perché seglie un'altra strada). 

Si può permettere agli agenti di rivalutare il proprio piano ogni qual volta raggiunge
un passaggio, questo perché quando raggiunge un passaggio l'agente ottiene le informazioni
di congestione della regione successiva, perciò risulta sensato ripianificare 
il percorso. La ripianificazione del piano può avvenire con un timer, non solo 
attraverso l'attraversamento dei passaggi tra regioni.

\begin{nota}
    Se gli agenti non avessero il piano tattico, significa che non ripianificano
    i percorsi.
\end{nota}

Per via che le persone sono influenzate dagli altri allora il modello non rispecchia
la realtà. Ha più senso effettuare una scelta non deterministica tra i percorsi 
da prendere influenzata dai tempi di percorrenza (a flusso libero), più precisamente 
si cerca di dare maggior probabilità alla via migliore senza azzerare le altre possibilità.
Per influenzare le scelte in base all'afflusso delle persone si misura la congestione 
in base al numero di persone e le dimensioni dei passaggi.
Per influenzare le scelte in base ai vicini, si introduce un area di influenza 
in cui se uno cambia piano allora fa scattare il cambio del piano anche ai vicini.

I limiti di questo modello sono:
\begin{itemize}
    \item agenti hanno una mappa dell'ambiente
    \item da questo modello si ottengono dei risultati a livello complessivo e non 
    a livello di agente.
    \item non si conoscono i modi con coi realmente gli agenti esplorano l'ambiente.
\end{itemize}   

\section{Valutazione dei modelli di simulazione}
La differenza tra sviluppare un gioco e fare una simulazione è il fatto che 
nella simulazione si hanno dei reali sistemi che si vogliono simulare, si ottengono
i dati e successivamente si analizzano, questi passi non vengono svolti per un gioco.
Lo scopo di simulare è per utilizzare il modello per spiegare e/o predire ragionamenti.

Per valutare un modello si crea un modello naive semplice che effettua una prima 
valutazione sulla bontà, questo permette già di effettuare una prima valutazione 
evitando di implementare anche le specificità. Se passa la valutazione si 
effettua un'analisi di sentitività sui paramentri del modello, ovvero si controlla quali paramentri
sono signficativi e quali possono essere i range utili per ciascun paramentro.
Se i parametri non sono sensibili allora possono essere anche rimossi dal modello.
Successivamente si effettua una calibrazione dei parametri per renderlo il più federe 
possibile alla realtà. Successivamente si può effettuare una validazione statistica 
ed infine si effettua il deploy.

Raccogliere dati empirici per poi confrontarli con il simulatore è sempre un problema,
infatti si possono introdurre dei bias nelle misurazioni, ex: utilizzare un gruppo 
di persone omogeno al posto di un gruppo eterogeneo.

Ricorda che i dati si ricavano dagli agenti ma le validazioni si effettuano sul
livello macroscopico.